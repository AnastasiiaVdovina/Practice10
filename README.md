# Практична робота №10
## Завдання 
### Умова

Створіть програму, яка після виклику fork() змінює значення глобальної змінної у батьківському процесі. Виведіть значення змінної в обох процесах, щоб переконатися, що дані не спільні.

### Рішення
Я написала просту демонстраційну програму. Я підключила всі необхідні бібліотеки та створила глобальну змінну, якій надала значення 0. Далі я створила копію поточного процесу за допомогою fork(). Далі я побудувала наступну логіку програми: 
- якщо pid < 0, то fork() неуспішний, виходимо з помилкою;
- якщо pid == 0, то ми знаходимось у дочірньому процесі. тоді виконаємо такі дії: виведемо значення глобальної змінної(скопійоване з батьківського процесу), інкрементуємо глобальну змінну та виведемо її значення ще раз;
- якщо pid > 0 , то ми знаходимося в батьківському процесі. повторюємо такі ж дії, як і для дочірнього, але замість інкременту я вирішила змінити значення глобальної змінної на 10;

Після виконання такої логіки, в результаті ми побачимо, що дочірній процес скопіював значеня глобальної змінної з батьківського процесу, тобто ці дані не спільні, що і треба було показати. Після fork() обидва процеси мають свої окремі копії пам’яті, тому  кожен має свою версію змінної global_var.

![image](https://github.com/user-attachments/assets/48639346-1c2d-4ef7-92f0-cd80f34aa330)

Також в цьому коді було використано ```wait(NULL)``` у батьківському процесі, щоб дочекатись завершення дочірнього. Як було сказано в лекції, якщо wait() не викликається, дочірні процеси залишаються в таблиці процесів як зомбі.



## Компіляція та запуск
Команда компіляції програми:
```
gcc -Wall task.c -o task
```

Запуск:
```
./task
```
